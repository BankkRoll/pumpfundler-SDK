---
title: "Creating Tokens"
description: "Comprehensive guide on creating tokens and executing bundled buy transactions with multiple buyers using the PumpFundler SDK"
---

# Advanced Token Creation and Bundled Buying with PumpFundler SDK

This guide demonstrates how to create a new token and execute bundled buy transactions with multiple buyers using the PumpFundler SDK. We'll focus on the advanced `createAndBuy` method, which allows for efficient token creation and immediate buying in a bundled transaction.

## Prerequisites

Before proceeding, ensure you have:

1. Initialized the PumpFundler SDK
2. A funded Solana wallet
3. Necessary permissions for token creation and buying

## The createAndBuy Process

The `createAndBuy` method in the PumpFundler SDK allows for creating a new token and executing multiple buy transactions in a single, bundled operation. Here's a detailed breakdown of the process:

### Step 1: Set Up SDK and Generate Keypairs

First, initialize the SDK and generate necessary keypairs:

```typescript
import { PumpFunSDK, CreateTokenMetadata, PumpFunConfig } from "pumpfundler-sdk";
import { Connection, Keypair } from "@solana/web3.js";
import { AnchorProvider, Wallet } from "@coral-xyz/anchor";

// Initialize connection and wallet
const connection = new Connection("https://api.mainnet-beta.solana.com");
const wallet = new Wallet(Keypair.generate());

// Configure SDK
const config: PumpFunConfig = {
  connection,
  jitoFee: 1000000, // 0.001 SOL
  commitmentLevel: "confirmed",
  blockEngineUrl: "https://your-jito-block-engine-url.com",
  jitoAuthKeypair: "your-jito-auth-keypair-base58-encoded",
};

const provider = new AnchorProvider(connection, wallet, {});
const sdk = new PumpFunSDK(provider, config);

// Generate keypairs for token creator and mint
const creator = Keypair.generate();
const mint = Keypair.generate();
```

### Step 2: Prepare Token Metadata

Create the token metadata:

```typescript
const createTokenMetadata: CreateTokenMetadata = {
  name: "My PumpFundler Token",
  symbol: "MPT",
  description: "A sample token created with PumpFundler SDK",
  file: new Blob([/* your image data */], { type: 'image/png' }),
  twitter: "https://twitter.com/mytoken",
  telegram: "https://t.me/mytoken",
  website: "https://mytoken.com"
};
```

### Step 3: Set Up Multiple Buyers

Generate keypairs for multiple buyers:

```typescript
const buyers = [
  Keypair.generate(),
  Keypair.generate(),
  Keypair.generate(),
  Keypair.generate(),
  Keypair.generate()
];
```

### Step 4: Configure Buy Parameters

Set up the buy amount and slippage tolerance:

```typescript
const buyAmountSol = BigInt(1_000_000_000); // 1 SOL
const slippageBasisPoints = 300n; // 3% slippage tolerance
```

### Step 5: Execute createAndBuy

Now, let's use the `createAndBuy` method to create the token and execute buy transactions for multiple buyers:

```typescript
async function createTokenAndExecuteBundledBuys() {
  try {
    const result = await sdk.createAndBuy(
      creator,
      mint,
      buyers,
      createTokenMetadata,
      buyAmountSol,
      slippageBasisPoints
    );

    if (result.confirmed) {
      console.log("Token created and buy transactions executed successfully");
      console.log("Jito transaction signature:", result.jitoTxsignature);
    } else {
      console.error("Failed to create token and execute buy transactions");
    }
  } catch (error) {
    console.error("Error in createAndBuy process:", error);
  }
}

createTokenAndExecuteBundledBuys();
```

## Understanding the Bundling Process

The `createAndBuy` method internally handles the bundling of transactions. Here's a detailed explanation of how it works:

1. **Token Creation Transaction**:
   - The method first creates a transaction for token creation using `getCreateInstructions`.
   - This transaction is built into a versioned transaction.

2. **Multiple Buy Transactions**:
   - For each buyer in the `buyers` array, a separate buy transaction is created.
   - The buy amount for each buyer is slightly randomized to add variability:

     ```typescript
     const randomPercent = getRandomInt(10, 25);
     const buyAmountSolWithRandom = (buyAmountSol / BigInt(100)) * 
       BigInt(randomPercent % 2 ? 100 + randomPercent : 100 - randomPercent);
     ```

   - Each buy transaction is created using `getBuyInstructionsBySolAmount` and built into a versioned transaction.

3. **Bundling with Jito**:
   - All transactions (create and multiple buys) are bundled together.
   - The bundle is sent using `jitoWithAxios`, which handles the Jito integration for MEV protection.

4. **Retry Mechanism**:
   - The method includes a retry loop to ensure the bundle is confirmed:

     ```typescript
     let result;
     while (1) {
       result = await jitoWithAxios(
         [createVersionedTx, ...buyTxs],
         creator,
         this.config
       );
       if (result.confirmed) break;
     }
     ```

## Advanced Considerations for Bundled Transactions

### 1. Transaction Size Limits

When bundling multiple transactions, be aware of Solana's transaction size limits. The `createAndBuy` method handles this by limiting the number of transactions in a bundle:

```typescript
const MAX_TRANSACTIONS_PER_BUNDLE = 3;
// ... (code to split transactions into multiple bundles if needed)
```

### 2. Jito Fee Management

The Jito fee is crucial for ensuring your bundled transactions are processed efficiently:

```typescript
const jitoFee = 1000000; // 0.001 SOL
// This fee is used in the jitoWithAxios function
```

### 3. Error Handling for Individual Transactions

While the entire bundle is processed atomically, you may want to handle errors for individual transactions:

```typescript
async function handleIndividualTransactions(transactions: VersionedTransaction[]) {
  for (let i = 0; i < transactions.length; i++) {
    try {
      // Simulate each transaction individually
      await connection.simulateTransaction(transactions[i]);
    } catch (error) {
      console.error(`Error in transaction ${i}:`, error);
      // Handle or log the error, but don't throw to allow other transactions to proceed
    }
  }
}
```

### 4. Monitoring Bundle Progress

Implement a monitoring system to track the progress of your bundled transactions:

```typescript
class BundleMonitor {
  private totalTransactions: number;
  private confirmedTransactions: number = 0;

  constructor(totalTransactions: number) {
    this.totalTransactions = totalTransactions;
  }

  updateProgress(confirmedTransactions: number) {
    this.confirmedTransactions = confirmedTransactions;
    const progress = (this.confirmedTransactions / this.totalTransactions) * 100;
    console.log(`Bundle progress: ${progress.toFixed(2)}%`);
  }
}

// Usage in createAndBuy
const monitor = new BundleMonitor(1 + buyers.length); // 1 create + number of buy transactions
// ... update monitor in the confirmation loop
```

## Best Practices for Bundled Token Creation and Buying

1. **Simulation Before Bundling**: Simulate all transactions individually before bundling to catch potential errors early:

   ```typescript
   async function simulateAllTransactions(createTx: Transaction, buyTxs: Transaction[]) {
     await connection.simulateTransaction(createTx);
     for (const buyTx of buyTxs) {
       await connection.simulateTransaction(buyTx);
     }
   }
   ```

2. **Dynamic Fee Adjustment**: Implement a system to dynamically adjust the Jito fee based on network conditions:

   ```typescript
   async function getOptimalJitoFee(connection: Connection): Promise<number> {
     const recentPerformance = await connection.getRecentPerformanceSamples(10);
     const avgTps = recentPerformance.reduce((sum, sample) => sum + sample.numTransactions, 0) / recentPerformance.length;
     return Math.max(1000000, Math.floor(avgTps * 100)); // Minimum 0.001 SOL, scales with TPS
   }
   ```

3. **Graceful Degradation**: Implement a fallback mechanism for when bundling fails:

   ```typescript
   async function createAndBuyWithFallback(/* params */) {
     try {
       return await sdk.createAndBuy(/* params */);
     } catch (error) {
       console.warn("Bundled transaction failed, falling back to individual transactions");
       const createResult = await sdk.createToken(/* params */);
       const buyResults = await Promise.all(buyers.map(buyer => sdk.buy(/* params */)));
       return { createResult, buyResults };
     }
   }
   ```

4. **Event Emission for Bundle Steps**: Implement a detailed event system to track each step of the bundled process:

   ```typescript
   class BundleStepEvent extends Event {
     constructor(public step: string, public details: any) {
       super('bundleStep');
     }
   }

   // Usage
   dispatchEvent(new BundleStepEvent('tokenCreated', { mint: mint.publicKey.toBase58() }));
   dispatchEvent(new BundleStepEvent('buyExecuted', { buyer: buyer.publicKey.toBase58(), amount: buyAmount }));
   ```