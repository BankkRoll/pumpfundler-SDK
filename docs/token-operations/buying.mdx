---
title: "Buying Tokens"
description: "Comprehensive guide on buying tokens with multiple buyers and bundling transactions using the PumpFundler SDK"
---

# Advanced Token Buying and Bundling with PumpFundler SDK

This guide demonstrates how to execute bundled buy transactions for multiple buyers using the PumpFundler SDK. We'll focus on the advanced bundling capabilities, which allow for efficient and MEV-protected token purchases.

## Prerequisites

Before proceeding, ensure you have:

1. Initialized the PumpFundler SDK
2. Funded Solana wallets for multiple buyers
3. The public key of the token's mint account

## The Bundled Buying Process

The bundled buying process involves several steps:

1. Setting up the SDK and buyer wallets
2. Preparing buy instructions for each buyer
3. Bundling the transactions
4. Executing the bundled transactions with Jito integration

Let's break down each step in detail.

### Step 1: Set Up SDK and Buyer Wallets

First, initialize the SDK and set up wallets for multiple buyers:

```typescript
import { PumpFunSDK, PumpFunConfig } from "pumpfundler-sdk";
import { Connection, Keypair, PublicKey } from "@solana/web3.js";
import { AnchorProvider, Wallet } from "@coral-xyz/anchor";

// Initialize connection and SDK
const connection = new Connection("https://api.mainnet-beta.solana.com");
const wallet = new Wallet(Keypair.generate());

const config: PumpFunConfig = {
  connection,
  jitoFee: 1000000, // 0.001 SOL
  commitmentLevel: "confirmed",
  blockEngineUrl: "https://your-jito-block-engine-url.com",
  jitoAuthKeypair: "your-jito-auth-keypair-base58-encoded",
};

const provider = new AnchorProvider(connection, wallet, {});
const sdk = new PumpFunSDK(provider, config);

// Set up buyer wallets
const buyers = [
  Keypair.generate(),
  Keypair.generate(),
  Keypair.generate(),
  Keypair.generate(),
  Keypair.generate()
];

// Token mint public key
const tokenMint = new PublicKey("your-token-mint-public-key");
```

### Step 2: Prepare Buy Instructions

Next, we'll prepare buy instructions for each buyer:

```typescript
async function prepareBuyInstructions(
  buyers: Keypair[],
  tokenMint: PublicKey,
  baseBuyAmount: bigint,
  slippageBasisPoints: bigint
) {
  const buyInstructions = [];

  for (const buyer of buyers) {
    // Randomize buy amount slightly for each buyer
    const randomFactor = BigInt(95 + Math.floor(Math.random() * 11)); // 95% to 105%
    const buyAmount = (baseBuyAmount * randomFactor) / BigInt(100);

    const buyTx = await sdk.getBuyInstructionsBySolAmount(
      buyer.publicKey,
      tokenMint,
      buyAmount,
      slippageBasisPoints
    );

    buyInstructions.push(buyTx);
  }

  return buyInstructions;
}

const baseBuyAmount = BigInt(1_000_000_000); // 1 SOL
const slippageBasisPoints = 300n; // 3% slippage tolerance

const buyInstructions = await prepareBuyInstructions(buyers, tokenMint, baseBuyAmount, slippageBasisPoints);
```

### Step 3: Bundle Transactions

Now, let's bundle these transactions using the SDK's bundling capabilities:

```typescript
import { VersionedTransaction } from "@solana/web3.js";
import { buildTx } from "pumpfundler-sdk";

async function bundleTransactions(buyInstructions: Transaction[], buyers: Keypair[]) {
  const versionedTxs: VersionedTransaction[] = [];

  for (let i = 0; i < buyInstructions.length; i++) {
    const versionedTx = await buildTx(
      sdk.connection,
      buyInstructions[i],
      buyers[i].publicKey,
      [buyers[i]],
      { unitLimit: 200000, unitPrice: 1000 }, // Priority fee
      "confirmed"
    );
    versionedTxs.push(versionedTx);
  }

  return versionedTxs;
}

const bundledTransactions = await bundleTransactions(buyInstructions, buyers);
```

### Step 4: Execute Bundled Transactions

Finally, we'll execute the bundled transactions using Jito integration:

```typescript
import { jitoWithAxios } from "pumpfundler-sdk";

async function executeBundledBuys(bundledTransactions: VersionedTransaction[], payer: Keypair) {
  try {
    const result = await jitoWithAxios(bundledTransactions, payer, sdk.config);

    if (result.confirmed) {
      console.log("Bundled buy transactions executed successfully");
      console.log("Jito transaction signature:", result.jitoTxsignature);
      return true;
    } else {
      console.error("Failed to execute bundled buy transactions");
      return false;
    }
  } catch (error) {
    console.error("Error in bundled buy execution:", error);
    return false;
  }
}

const bundleExecutionResult = await executeBundledBuys(bundledTransactions, wallet.payer);
```

## Advanced Considerations for Bundled Buying

### 1. Transaction Size Limits

When bundling multiple buy transactions, be aware of Solana's transaction size limits. The `jitoWithAxios` function handles this by limiting the number of transactions in a bundle:

```typescript
const MAX_TRANSACTIONS_PER_BUNDLE = 3;
// This is handled internally in jitoWithAxios
```

### 2. Jito Fee Management

The Jito fee is crucial for ensuring your bundled transactions are processed efficiently:

```typescript
const jitoFee = 1000000; // 0.001 SOL
// This fee is used in the jitoWithAxios function
```

### 3. Error Handling for Individual Transactions

While the entire bundle is processed atomically, you may want to handle errors for individual transactions:

```typescript
async function handleIndividualTransactions(transactions: VersionedTransaction[]) {
  for (let i = 0; i < transactions.length; i++) {
    try {
      // Simulate each transaction individually
      await sdk.connection.simulateTransaction(transactions[i]);
    } catch (error) {
      console.error(`Error in transaction ${i}:`, error);
      // Handle or log the error, but don't throw to allow other transactions to proceed
    }
  }
}
```

### 4. Monitoring Bundle Progress

Implement a monitoring system to track the progress of your bundled transactions:

```typescript
class BundleMonitor {
  private totalTransactions: number;
  private confirmedTransactions: number = 0;

  constructor(totalTransactions: number) {
    this.totalTransactions = totalTransactions;
  }

  updateProgress(confirmedTransactions: number) {
    this.confirmedTransactions = confirmedTransactions;
    const progress = (this.confirmedTransactions / this.totalTransactions) * 100;
    console.log(`Bundle progress: ${progress.toFixed(2)}%`);
  }
}

// Usage in executeBundledBuys
const monitor = new BundleMonitor(bundledTransactions.length);
// ... update monitor in the confirmation loop
```

## Best Practices for Bundled Token Buying

1. **Simulation Before Bundling**: Simulate all transactions individually before bundling to catch potential errors early:

   ```typescript
   async function simulateAllTransactions(transactions: VersionedTransaction[]) {
     for (const tx of transactions) {
       await sdk.connection.simulateTransaction(tx);
     }
   }
   ```

2. **Dynamic Fee Adjustment**: Implement a system to dynamically adjust the Jito fee based on network conditions:

   ```typescript
   async function getOptimalJitoFee(connection: Connection): Promise<number> {
     const recentPerformance = await connection.getRecentPerformanceSamples(10);
     const avgTps = recentPerformance.reduce((sum, sample) => sum + sample.numTransactions, 0) / recentPerformance.length;
     return Math.max(1000000, Math.floor(avgTps * 100)); // Minimum 0.001 SOL, scales with TPS
   }
   ```

3. **Graceful Degradation**: Implement a fallback mechanism for when bundling fails:

   ```typescript
   async function buyWithFallback(buyers: Keypair[], tokenMint: PublicKey, buyAmount: bigint) {
     try {
       return await executeBundledBuys(/* ... */);
     } catch (error) {
       console.warn("Bundled transaction failed, falling back to individual transactions");
       const buyResults = await Promise.all(buyers.map(buyer => 
         sdk.buy(buyer, tokenMint, buyAmount)
       ));
       return buyResults;
     }
   }
   ```

4. **Event Emission for Bundle Steps**: Implement a detailed event system to track each step of the bundled process:

   ```typescript
   class BundleStepEvent extends Event {
     constructor(public step: string, public details: any) {
       super('bundleStep');
     }
   }

   // Usage
   dispatchEvent(new BundleStepEvent('buyExecuted', { buyer: buyer.publicKey.toBase58(), amount: buyAmount }));
   ```
