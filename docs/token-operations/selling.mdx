---
title: "Selling Tokens"
description: "In-depth guide on selling tokens using the PumpFundler SDK"
---

# Selling Tokens

Selling tokens is a crucial operation in the PumpFundler ecosystem, allowing users to exchange their tokens back into SOL based on the bonding curve's current state. This guide provides a comprehensive look at the token selling process using the PumpFundler SDK.

## Prerequisites

Before selling tokens, ensure you have:

1. Initialized the PumpFundler SDK
2. A Solana wallet with the tokens you wish to sell
3. The public key of the token's bonding curve account

## The Selling Process

The token selling process involves several key steps:

1. Fetching the current state of the bonding curve
2. Calculating the expected SOL return
3. Creating and sending the sell transaction
4. Handling the transaction result

Let's examine each step in detail.

### Step 1: Fetch Bonding Curve State

First, we need to fetch the current state of the bonding curve:

```typescript
import { PumpFundlerSDK, BondingCurveAccount } from "pumpfundler-sdk";

const sdk = new PumpFundlerSDK(connection, wallet);

const bondingCurveAccount = await sdk.getBondingCurveAccount(bondingCurvePubkey);
```

### Step 2: Calculate Expected SOL Return

Next, we'll calculate the expected SOL return for a given token amount:

```typescript
import { AMM } from "pumpfundler-sdk";

const amm = AMM.fromBondingCurveAccount(
  bondingCurveAccount,
  sdk.globalAccount.initialVirtualTokenReserves
);

const tokenAmount = BigInt(1000 * 10**9); // 1000 tokens (assuming 9 decimals)
const expectedSol = amm.getSolForTokens(tokenAmount);
```

### Step 3: Create and Send Sell Transaction

Now, let's create and send the sell transaction:

```typescript
import { web3 } from "@project-serum/anchor";

const sellParams = {
  bondingCurve: bondingCurvePubkey,
  amount: tokenAmount,
  minSol: expectedSol, // Set a minimum to protect against slippage
};

const sellTx = await sdk.sell(sellParams);
const signature = await sellTx.send();
const confirmation = await sellTx.confirm();
```

### Step 4: Handle Transaction Result

Finally, we'll handle the transaction result:

```typescript
if (confirmation.value.err) {
  throw new Error(`Transaction failed: \${JSON.stringify(confirmation.value.err)}`);
}

const solBalance = await connection.getBalance(wallet.publicKey);
console.log(`Successfully sold tokens. New SOL balance: \${solBalance / 10**9} SOL`);
```

## Advanced Considerations

### Slippage Protection

Implement slippage protection to guard against price fluctuations:

```typescript
const slippageTolerance = 0.01; // 1%
const minSol = expectedSol * BigInt(Math.floor((1 - slippageTolerance) * 100)) / BigInt(100);

const sellParams = {
  // ... other params ...
  minSol: minSol,
};
```

### Dynamic Fee Adjustment

Adjust fees based on network congestion for faster confirmations:

```typescript
import { ComputeBudgetProgram } from "@solana/web3.js";

async function getDynamicPriorityFee() {
  const recentPrioritizationFees = await connection.getRecentPrioritizationFees();
  const maxFee = Math.max(...recentPrioritizationFees.map(fee => fee.prioritizationFee));
  return maxFee + 1; // Add 1 to ensure our transaction is prioritized
}

const priorityFee = await getDynamicPriorityFee();
const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: priorityFee
});

sellTx.add(priorityFeeIx);
```

### Partial Fills

Implement a partial fill mechanism for large sell orders:

```typescript
async function partialSell(totalTokenAmount: bigint, minFillPercentage: number = 0.9) {
  let remainingTokens = totalTokenAmount;
  let totalSolReceived = BigInt(0);

  while (remainingTokens > 0) {
    const amm = AMM.fromBondingCurveAccount(
      await sdk.getBondingCurveAccount(bondingCurvePubkey),
      sdk.globalAccount.initialVirtualTokenReserves
    );

    const expectedSol = amm.getSolForTokens(remainingTokens);
    const minSol = expectedSol * BigInt(Math.floor(minFillPercentage * 100)) / BigInt(100);

    try {
      const sellTx = await sdk.sell({
        bondingCurve: bondingCurvePubkey,
        amount: remainingTokens,
        minSol: minSol,
      });
      const confirmation = await sellTx.confirm();

      if (confirmation.value.err) {
        throw new Error(`Transaction failed: \${JSON.stringify(confirmation.value.err)}`);
      }

      const solReceived = BigInt(confirmation.meta.postBalances[0]) - BigInt(confirmation.meta.preBalances[0]);
      totalSolReceived += solReceived;
      remainingTokens = BigInt(0);
    } catch (error) {
      // If the transaction fails, try selling half the amount
      remainingTokens = remainingTokens / BigInt(2);
    }
  }

  return totalSolReceived;
}
```

### Event-Driven Architecture

Implement an event system to react to successful sells:

```typescript
class TokenSoldEvent extends Event {
  constructor(public tokenAmount: bigint, public solAmount: bigint) {
    super('tokenSold');
  }
}

// After successful sell
dispatchEvent(new TokenSoldEvent(tokenAmount, solReceived));
```

## Best Practices

1. **Pre-flight Checks**: Perform pre-flight checks to ensure the operation is likely to succeed:

   ```typescript
   const userTokenBalance = await sdk.getTokenBalance(userTokenAccount);
   if (userTokenBalance < tokenAmount) {
     throw new Error("Insufficient token balance");
   }
   ```

2. **Transaction Simulation**: Simulate the transaction before sending to catch potential errors:

   ```typescript
   const simulation = await connection.simulateTransaction(sellTx.transaction);
   if (simulation.value.err) {
     throw new Error(`Transaction simulation failed: \${JSON.stringify(simulation.value.err)}`);
   }
   ```

3. **Retry Mechanism with Exponential Backoff**: Implement a retry mechanism with exponential backoff for failed transactions due to network issues:

   ```typescript
   async function retrySell(maxRetries = 5) {
     let retries = 0;
     while (retries < maxRetries) {
       try {
         const sellTx = await sdk.sell(sellParams);
         return await sellTx.confirm();
       } catch (error) {
         if (error instanceof web3.SendTransactionError) {
           retries++;
           const delay = Math.pow(2, retries) * 1000; // Exponential backoff
           await new Promise(resolve => setTimeout(resolve, delay));
         } else {
           throw error;
         }
       }
     }
     throw new Error("Max retries reached");
   }
   ```

4. **Graceful Degradation**: Implement fallback mechanisms for when the primary selling method fails:

   ```typescript
   async function sellWithFallback(tokenAmount: bigint) {
     try {
       // Try primary selling method
       return await sdk.sell(sellParams);
     } catch (error) {
       console.warn("Primary selling method failed, attempting fallback");
       // Fallback to a different bonding curve or DEX
       return await alternativeSellMethod(tokenAmount);
     }
   }
   ```

5. **Monitoring and Alerting**: Implement a monitoring system to track successful and failed sells:

   ```typescript
   class SellMonitor {
     private successfulSells: number = 0;
     private failedSells: number = 0;

     recordSuccess() {
       this.successfulSells++;
       this.checkThresholds();
     }

     recordFailure() {
       this.failedSells++;
       this.checkThresholds();
     }

     private checkThresholds() {
       if (this.failedSells > 10) {
         this.sendAlert("High number of failed sells detected");
       }
       if (this.successfulSells > 100) {
         this.sendAlert("High volume of successful sells detected");
       }
     }

     private sendAlert(message: string) {
       // Implement your alerting mechanism here (e.g., email, Slack notification)
       console.log(`ALERT: \${message}`);
     }
   }

   const sellMonitor = new SellMonitor();

   // Use in your sell function
   try {
     await sdk.sell(sellParams);
     sellMonitor.recordSuccess();
   } catch (error) {
     sellMonitor.recordFailure();
     throw error;
   }
   ```